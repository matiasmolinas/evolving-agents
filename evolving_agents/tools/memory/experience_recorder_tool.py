# evolving_agents/tools/memory/experience_recorder_tool.py
import logging
from typing import List, Dict, Optional, Any, Type # Added Type for schema
from pydantic import BaseModel, Field
import json # For formatting task description for MemoryManagerAgent

from beeai_framework.tools.tool import Tool, StringToolOutput # Correct import
from beeai_framework.emitter.emitter import Emitter # Required for Tool
from beeai_framework.context import RunContext # Required for Tool._run signature

from evolving_agents.agent_bus.smart_agent_bus import SmartAgentBus

# Configure logging
logger = logging.getLogger(__name__)

class ExperienceDataInput(BaseModel):
    """
    Schema for the input data required to record an experience.
    These fields will be passed to the MemoryManagerAgent for storage.
    """
    primary_goal_description: str = Field(..., description="Description of the overall goal.")
    sub_task_description: str = Field(..., description="Description of the specific sub-task.")
    initiating_agent_id: str = Field(..., description="ID of the agent that initiated this task.")
    final_outcome: str = Field(..., description="Final outcome (e.g., 'success', 'failure', 'suboptimal_routing').")
    
    # Optional fields that provide more context about the experience
    components_used: Optional[List[str]] = Field(default=None, description="List of component IDs or names involved in achieving the outcome.")
    input_context_summary: Optional[str] = Field(default=None, description="A brief summary of the input context provided for the task.")
    key_decisions_made: Optional[List[str]] = Field(default=None, description="A list of key decisions made by the agent(s) during the task execution.")
    output_summary: Optional[str] = Field(default=None, description="A summary of the output or result generated by the task.")
    reasoning_snippet: Optional[str] = Field(default=None, description="A snippet of the agent's reasoning or thought process leading to the outcome.")
    feedback_signals: Optional[Dict[str, Any]] = Field(default=None, description="Structured feedback received related to this experience (e.g., user ratings, corrections).")
    
    workflow_id: Optional[str] = Field(default=None, description="Identifier for a larger workflow this experience is part of, if applicable.")
    session_id: Optional[str] = Field(default=None, description="Identifier for the user session or interaction this experience belongs to.")
    tags: Optional[List[str]] = Field(default_factory=list, description="Descriptive tags for categorizing or searching for this experience.")
    
    # Note: experience_id, timestamp, version, and embeddings are typically
    # generated by the MongoExperienceStoreTool within MemoryManagerAgent, not taken as input here.

class ExperienceRecorderToolOutput(BaseModel): # Define an output schema
    status: str = Field(description="Status of the recording operation ('success' or 'error').")
    experience_id: Optional[str] = Field(None, description="The ID of the recorded experience if successful.")
    message: str = Field(description="A message detailing the outcome of the operation.")

class ExperienceRecorderTool(Tool[ExperienceDataInput, None, ExperienceRecorderToolOutput]):
    """
    Records a completed task or workflow as a structured experience
    in the Smart Memory system by delegating to the MemoryManagerAgent via the SmartAgentBus.
    """
    name: str = "ExperienceRecorderTool"
    description: str = (
        "Records a task/workflow experience in Smart Memory via MemoryManagerAgent. "
        "Provide all relevant details (goal, outcome, components, etc.) as input."
    )
    input_schema: Type[BaseModel] = ExperienceDataInput
    output_schema: Type[BaseModel] = ExperienceRecorderToolOutput

    def __init__(
        self,
        agent_bus: SmartAgentBus,
        memory_manager_agent_id: str,
        options: Optional[Dict[str, Any]] = None # For Tool base class
    ):
        super().__init__(options=options) # Call Tool's __init__
        if agent_bus is None:
            raise ValueError("agent_bus cannot be None for ExperienceRecorderTool")
        if not memory_manager_agent_id:
            raise ValueError("memory_manager_agent_id must be provided.")
            
        self.agent_bus = agent_bus
        self.memory_manager_agent_id = memory_manager_agent_id

    def _create_emitter(self) -> Emitter: # Implement required method
        return Emitter.root().child(
            namespace=["tool", "memory", "experience_recorder"],
            creator=self,
        )

    async def _run(
        self, 
        input: ExperienceDataInput, # Input is now an instance of ExperienceDataInput
        options: Optional[Dict[str, Any]] = None, 
        context: Optional[RunContext] = None
    ) -> ExperienceRecorderToolOutput:
        """
        Records an experience by sending its details to the MemoryManagerAgent.
        The input `input` is an instance of ExperienceDataInput.
        """
        # experience_data is already validated and structured by Pydantic
        experience_data_dict = input.model_dump(exclude_none=True) # Convert Pydantic model to dict
        logger.debug(f"Experience data for recording: {experience_data_dict}")
        
        # Format the experience data into a task description for the MemoryManagerAgent (ReAct)
        experience_data_json_string = json.dumps(experience_data_dict)
        
        task_for_memory_manager = (
            f"Store the following agent experience: {experience_data_json_string}. "
            "Ensure all provided fields are saved. Respond with the experience_id upon successful storage."
        )

        try:
            logger.info(
                f"Sending request to MemoryManagerAgent ({self.memory_manager_agent_id}) "
                f"to store experience for goal: '{input.primary_goal_description[:50]}...'"
            )
            
            # SmartAgentBus.request_capability expects content as a dict.
            # MemoryManagerAgent's run method (as a ReActAgent) expects a task_description string.
            # So, we wrap the task_description string in a dict for the bus.
            bus_payload = {"task_description": task_for_memory_manager}
            bus_capability_name = "process_task" # Generic capability for MemoryManagerAgent

            response = await self.agent_bus.request_capability(
                capability=bus_capability_name,
                content=bus_payload, 
                specific_agent_id=self.memory_manager_agent_id, # Use specific_agent_id for clarity
                # min_confidence is not typically used when targeting a specific agent
                timeout=120 # Example timeout
            )
            
            logger.debug(f"Raw response from MemoryManagerAgent: {response}")

            # Process the response from MemoryManagerAgent
            # The MemoryManagerAgent (ReAct) using MongoExperienceStoreTool should ideally return
            # a structured response or at least the experience_id in its final_answer.
            
            if isinstance(response, dict):
                # Check for a direct success status and experience_id from MMA's tool
                if response.get("status") == "success" and response.get("experience_id"):
                    return ExperienceRecorderToolOutput(
                        status="success", 
                        experience_id=response["experience_id"],
                        message="Experience recorded successfully by MemoryManagerAgent."
                    )
                # Check for ReAct agent's final_answer pattern
                elif response.get("final_answer") and isinstance(response["final_answer"], str) and response["final_answer"].startswith("exp_"):
                    return ExperienceRecorderToolOutput(
                        status="success",
                        experience_id=response["final_answer"],
                        message="Experience recorded successfully (extracted from final_answer)."
                    )
                # Handle other dict responses from MMA that might indicate an issue
                else:
                    error_message = response.get("message", response.get("error", str(response)))
                    logger.warning(f"MemoryManagerAgent reported an issue or unexpected response structure: {error_message}")
                    return ExperienceRecorderToolOutput(
                        status="error", 
                        message=f"MemoryManagerAgent processing issue: {error_message}"
                    )
            elif isinstance(response, str) and response.startswith("exp_"): # Direct string experience_id
                 return ExperienceRecorderToolOutput(
                        status="success", 
                        experience_id=response,
                        message="Experience recorded successfully (direct ID string)."
                    )
            else:
                logger.warning(f"Unexpected response type/content from MemoryManagerAgent: {type(response)}, content: {str(response)[:200]}")
                return ExperienceRecorderToolOutput(
                    status="error", 
                    message=f"Unexpected response from MemoryManagerAgent: {str(response)[:200]}"
                )

        except Exception as e:
            logger.error(f"Error during SmartAgentBus request to MemoryManagerAgent: {e}", exc_info=True)
            return ExperienceRecorderToolOutput(
                status="error", 
                message=f"Failed to record experience via bus: {e}"
            )

# Example (Conceptual - requires SmartAgentBus and MemoryManagerAgent setup)
# async def main_example():
#     # ... (Requires extensive mocking or full setup of SmartAgentBus, MemoryManagerAgent, etc.) ...
#     # Assuming container and agent_bus are set up correctly, and MEMORY_MANAGER_AGENT_ID is known.
#     # experience_tool = ExperienceRecorderTool(
#     #     agent_bus=your_agent_bus_instance,
#     #     memory_manager_agent_id=MEMORY_MANAGER_AGENT_ID 
#     # )

#     # experience_input_data = ExperienceDataInput(
#     #     primary_goal_description="Test booking a flight for a conference",
#     #     sub_task_description="Search for flights from London Heathrow (LHR) to John F. Kennedy (JFK) for next week.",
#     #     initiating_agent_id="TravelPlannerAgent_v3",
#     #     final_outcome="success",
#     #     components_used=["FlightSearchAPITool_v2", "UserPreferencesDBTool_v1"],
#     #     input_context_summary="User needs a business class seat, prefers morning departures, budget $2000.",
#     #     key_decisions_made=[
#     #         "Decided to query British Airways API first based on user preference.",
#     #         "Filtered out flights with layovers longer than 3 hours.",
#     #         "Selected the cheapest direct flight within budget."
#     #     ],
#     #     output_summary="Found 3 suitable flights, presented the BA direct morning flight at $1850.",
#     #     feedback_signals={"user_rating": 5, "comment": "Perfect, exactly what I was looking for!"},
#     #     workflow_id="wf_flight_booking_conf_012",
#     #     session_id="user_session_abc123",
#     #     tags=["flight_booking", "conference_travel", "international", "business_class"]
#     # )

#     # print("\n--- Testing ExperienceRecorderTool ---")
#     # result = await experience_tool._run(input=experience_input_data) # Call _run with Pydantic model
#     # print(f"Result from ExperienceRecorderTool: {result.model_dump_json(indent=2)}")
#     pass

# if __name__ == "__main__":
#     import asyncio
#     # asyncio.run(main_example())
#     pass