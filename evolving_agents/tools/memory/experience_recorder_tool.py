import logging
from typing import List, Dict, Optional, Any, Union

from pydantic import BaseModel, Field, field_validator
import json # For formatting task description

from evolving_agents.core.base import BaseTool
from evolving_agents.agent_bus.smart_agent_bus import SmartAgentBus # Assuming this path

# Configure logging
logger = logging.getLogger(__name__)

class ExperienceDataInput(BaseModel):
    """
    Schema for the input data required to record an experience.
    All fields that are part of the core experience record should be listed here.
    """
    primary_goal_description: str = Field(..., description="Description of the overall goal.")
    sub_task_description: str = Field(..., description="Description of the specific sub-task.")
    initiating_agent_id: str = Field(..., description="ID of the agent that initiated this task.")
    final_outcome: str = Field(..., description="Final outcome (e.g., 'success', 'failure').")
    
    involved_components: Optional[List[str]] = Field(default=None, description="List of component IDs involved.")
    input_context_summary: Optional[str] = Field(default=None, description="Summary of the input context.")
    key_decisions_made: Optional[List[str]] = Field(default=None, description="Key decisions made by the agent.")
    output_summary: Optional[str] = Field(default=None, description="Summary of the output generated.")
    feedback_signals: Optional[Dict[str, Any]] = Field(default=None, description="Structured feedback received.")
    
    workflow_id: Optional[str] = Field(default=None, description="Optional workflow identifier.")
    session_id: Optional[str] = Field(default=None, description="Optional session identifier.")
    tags: Optional[List[str]] = Field(default=None, description="Optional tags for categorization.")
    
    # Experience ID and other fields like timestamp, version, embeddings are typically
    # generated by MongoExperienceStoreTool within MemoryManagerAgent, so not taken as input here.

class ExperienceRecorderTool(BaseTool):
    """
    Records a completed task or workflow as a structured experience
    in the Smart Memory system by delegating to the MemoryManagerAgent via the SmartAgentBus.
    """
    name: str = "ExperienceRecorderTool"
    description: str = (
        "Records a completed task/workflow as a structured experience in the Smart Memory system "
        "via the MemoryManagerAgent. Provide all relevant details of the experience."
    )
    input_schema: Dict[str, Any] = ExperienceDataInput.model_json_schema()
    output_schema: Dict[str, Any] = {
        "type": "object",
        "properties": {
            "status": {"type": "string", "enum": ["success", "error"]},
            "experience_id": {"type": "string", "description": "The ID of the recorded experience if successful."},
            "message": {"type": "string", "description": "Details in case of an error or success message."},
        },
        "required": ["status"]
    }

    def __init__(
        self,
        agent_bus: SmartAgentBus,
        memory_manager_agent_id: str,
    ):
        """
        Initializes the ExperienceRecorderTool.

        Args:
            agent_bus: An instance of SmartAgentBus to communicate with other agents.
            memory_manager_agent_id: The ID of the MemoryManagerAgent registered on the bus.
        """
        super().__init__()
        if agent_bus is None:
            raise ValueError("agent_bus cannot be None for ExperienceRecorderTool")
        if not memory_manager_agent_id:
            raise ValueError("memory_manager_agent_id must be provided.")
            
        self.agent_bus = agent_bus
        self.memory_manager_agent_id = memory_manager_agent_id

    async def run(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Records an experience by sending its details to the MemoryManagerAgent.

        Args:
            **kwargs: Fields matching the ExperienceDataInput schema.

        Returns:
            A dictionary with the status of the operation and either an experience_id
            or an error message.
        """
        try:
            experience_data = ExperienceDataInput(**kwargs).model_dump(exclude_none=True)
            logger.debug(f"Validated experience data for recording: {experience_data}")
        except Exception as e: # Pydantic's ValidationError is an Exception subclass
            logger.error(f"Input validation error for ExperienceRecorderTool: {e}", exc_info=True)
            return {"status": "error", "message": f"Input validation error: {e}"}

        # The MemoryManagerAgent is a ReAct agent. It expects a natural language task description.
        # We need to format the experience_data into such a description.
        # The task description should guide the MemoryManagerAgent to use its MongoExperienceStoreTool.store_experience method.
        
        # Convert dict to a JSON string for clear inclusion in the prompt,
        # or a more human-readable format if preferred. JSON is precise.
        experience_data_json_string = json.dumps(experience_data)
        
        task_for_memory_manager = (
            f"Store the following agent experience: {experience_data_json_string}. "
            "Ensure all provided fields are saved. Respond with the experience_id upon successful storage."
        )

        try:
            logger.info(
                f"Sending request to MemoryManagerAgent ({self.memory_manager_agent_id}) "
                f"to store experience."
            )
            
            # SmartAgentBus.request_capability expects capability name and content.
            # For a ReAct agent like MemoryManagerAgent, the 'capability' is effectively
            # the task description itself, and 'content' can be the task description or
            # a more structured dict if the ReAct agent is designed to parse it.
            # Given MemoryManagerAgent's ReAct nature, we pass task_for_memory_manager as content to its `run` method.
            # The `capability` argument to `request_capability` might be a generic one like "process_task"
            # or specific if the bus and agent are designed for it.
            # Let's assume a generic capability "process_task" for the bus,
            # and the actual task is in the 'content'.
            # Alternatively, if SmartAgentBus.request directly calls an agent's 'run' method,
            # the 'capability' string might not be used by the bus itself but passed to the agent.
            # Let's simplify: Assume `request_capability` is a general way to make an agent `run` a task.
            # The `capability` here is more of a routing hint for the bus, if it uses one,
            # or a way to specify which method on the target agent if it's not just `run`.
            # If MemoryManagerAgent has a method like `store_experience_via_bus_request`, that could be the capability.
            # However, the instruction for MemoryManagerAgent was to have a `run` method that takes a task_description.
            # So, the "capability" for the bus is more like "execute_task" or similar, and the content
            # is the task_description string for the MemoryManagerAgent's run method.

            # Let's assume the bus's `request_capability` method takes:
            # target_agent_id, capability_name (which might be ignored by a simple bus or used for routing/logging),
            # and then the actual payload for the target agent's `run` method (task_description).
            # The original prompt: "await self.agent_bus.request_capability(...)"
            # Worker Note: The SmartAgentBus.request_capability method expects capability (string) and content (dict).
            # This implies the 'content' for the bus is a dict.
            # The content for the MemoryManagerAgent's `run` method is a `task_description: str`.
            # This means the `content` for the bus should be a dict that MemoryManagerAgent can understand,
            # or the bus call needs to be adapted.
            # If `MemoryManagerAgent.run` takes `task_description: str`, then the bus's `content`
            # should probably be `{"task_description": task_for_memory_manager}` if the bus unpacks it,
            # or the `MemoryManagerAgent.run` signature should be `run(self, content: Dict[str, Any])`.
            # Let's stick to `MemoryManagerAgent.run(self, task_description: str)`.
            # This implies the `request_capability`'s `content` field for the bus should be the `task_for_memory_manager` string directly,
            # IF the bus is designed to pass that string directly as the argument to the target agent's method.
            # The note says "content (dict)". This is a conflict.

            # Option 1: Bus content is dict, MemoryManagerAgent.run adapts. (Changes MemoryManagerAgent - not ideal now)
            # Option 2: Bus content is dict, e.g. {"task_description": task_string}, bus adapts or MemoryManagerAgent.run expects this dict.
            # Option 3: The note "content (dict)" for request_capability is a general case, and for specific ReAct agents
            #           expecting a string, the bus or a wrapper would handle it.

            # Let's assume the `MemoryManagerAgent` is called via its `run(task_description:str)` method.
            # If `SmartAgentBus.request_capability` truly needs `content: dict`, we need to wrap `task_for_memory_manager`.
            # Let's assume `capability` is a generic "process_task" and content is `{"task_description": task_for_memory_manager}`
            # and the bus will correctly pass `task_for_memory_manager` to the `run` method.

            bus_payload = {"task_description": task_for_memory_manager}
            bus_capability_name = "process_task" # Generic capability name for invoking ReAct agent's run method

            response = await self.agent_bus.request_capability(
                target_agent_id=self.memory_manager_agent_id,
                capability=bus_capability_name, # This might be used by the bus for routing/logging or passed to agent
                content=bus_payload # This dict will be handled by the bus
            )
            
            # The `MemoryManagerAgent.run` method (which is `ReActAgent.run`) returns the result of the last tool call or final answer.
            # If MongoExperienceStoreTool.store_experience returns experience_id (string),
            # then MemoryManagerAgent's ReAct loop should provide this as the final answer.
            # We need to check the structure of `response`.
            
            logger.debug(f"Received response from MemoryManagerAgent: {response}")

            if isinstance(response, str) and response.startswith("exp_"): # Assuming experience_id is a string like "exp_..."
                return {"status": "success", "experience_id": response, "message": "Experience recorded successfully."}
            elif isinstance(response, dict): # If MemoryManagerAgent itself wraps the response
                if response.get("status") == "success" and response.get("experience_id"):
                     return response
                elif response.get("final_answer") and isinstance(response["final_answer"], str) and response["final_answer"].startswith("exp_"): # Common ReAct pattern
                     return {"status": "success", "experience_id": response["final_answer"], "message": "Experience recorded successfully."}
                else: # Attempt to find experience_id in a nested structure if ReAct returns complex output
                    # This part is speculative based on how ReAct might return things.
                    # A more robust way is to ensure MemoryManagerAgent's LLM prompt for storing
                    # explicitly asks for the experience_id as the Final Answer.
                    potential_id = response.get("experience_id", response.get("result", response.get("output")))
                    if isinstance(potential_id, str) and potential_id.startswith("exp_"):
                         return {"status": "success", "experience_id": potential_id, "message": "Experience recorded successfully."}
                    logger.warning(f"Unexpected response structure from MemoryManagerAgent: {response}")
                    return {"status": "error", "message": f"Unexpected response from MemoryManagerAgent: {response}"}
            else:
                logger.warning(f"Unexpected response type from MemoryManagerAgent: {type(response)}, content: {response}")
                return {"status": "error", "message": f"Unexpected response type from MemoryManagerAgent: {response}"}

        except Exception as e:
            logger.error(f"Error during SmartAgentBus request to MemoryManagerAgent: {e}", exc_info=True)
            return {"status": "error", "message": f"Failed to record experience: {e}"}

# Example (Conceptual - requires SmartAgentBus and MemoryManagerAgent setup)
# async def main_example():
#     class MockSmartAgentBus(SmartAgentBus):
#         async def request_capability(self, target_agent_id: str, capability: str, content: Dict[str, Any]) -> Any:
#             print(f"MockSmartAgentBus: Request to '{target_agent_id}' for capability '{capability}' with content: {content}")
#             if target_agent_id == "memory_manager_agent_001" and capability == "process_task":
#                 if "Store the following agent experience" in content.get("task_description", ""):
#                     # Simulate MemoryManagerAgent processing and returning experience_id
#                     return "exp_12345abcdef" 
#                 return {"status": "error", "message": "MemoryManagerAgent mock couldn't process task."}
#             return {"status": "error", "message": "Agent not found or capability not supported."}

#     mock_bus = MockSmartAgentBus(None) # type: ignore # Assuming bus constructor needs some config
    
#     experience_tool = ExperienceRecorderTool(
#         agent_bus=mock_bus,
#         memory_manager_agent_id="memory_manager_agent_001"
#     )

#     experience_details = {
#         "primary_goal_description": "Test booking a flight",
#         "sub_task_description": "Search for flights from LHR to JFK",
#         "initiating_agent_id": "booking_agent_v2",
#         "involved_components": ["FlightSearchAPI", "UserPreferencesDB"],
#         "input_context_summary": "User wants a business class seat, morning departure.",
#         "key_decisions_made": ["Queried BA API", "Filtered by duration < 10h"],
#         "final_outcome": "success",
#         "output_summary": "Found 3 suitable flights, cheapest option presented.",
#         "feedback_signals": {"user_rating": 5, "comment": "Great!"},
#         "workflow_id": "wf_flight_booking_789",
#         "tags": ["flight", "international"]
#     }

#     print("\n--- Testing ExperienceRecorderTool ---")
#     result = await experience_tool.run(**experience_details)
#     print(f"Result from ExperienceRecorderTool: {result}")

#     print("\n--- Testing with missing required field ---")
#     invalid_details = experience_details.copy()
#     del invalid_details["primary_goal_description"]
#     result_invalid = await experience_tool.run(**invalid_details)
#     print(f"Result from invalid input: {result_invalid}")


# if __name__ == "__main__":
#     import asyncio
#     # asyncio.run(main_example())
#     pass
